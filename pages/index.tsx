import type { NextPage } from 'next'
import Head from 'next/head'
import React from 'react'

import { AnswerSelectorProps, KnowledgeItem, Letter, LetterIndices, LetterState } from '../models';
import { Form, LettersWrapper, Letter as SLetter, Submit, Wrapper } from '../styles/styled';
import { replacer } from '../utils';

const alphabet = 'abcdefghijklmnopqrstuvwxyz';




const Home: NextPage = () => {
  const [gameState, setGameState] = React.useState('start');
  const [guesses, setGuesses] = React.useState<string[]>([]);
  const [firstWord, setFirstWord] = React.useState<string>('');
  const [firstGuessError, setFirstGuessError] = React.useState<boolean>(false);
  const [currentGlobalKnowledge, setCurrentGlobalKnowledge] = React.useState<Map<Letter, KnowledgeItem>>(generateInitialKnowledgeMap());

  const setInitialGuess: React.FormEventHandler<HTMLFormElement> = () => {
    if (/^[a-z]{5}$/.test(firstWord.toLowerCase())) {
      setGuesses([firstWord.toLowerCase()]);
      setGameState('playing');
      setFirstGuessError(false);
    } else {
      setFirstGuessError(true)
    }
  }

  return (
    <Wrapper>
      <Head>
        <title>Wordle Helper</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <h1>Wordle Helper</h1>
      {gameState === 'start' ? <>
        <Form onSubmit={setInitialGuess}>
          <label htmlFor='firstWord'>Enter your initial guess:
            <input type='text' id='firstWord' onChange={(e) => setFirstWord(e.target.value)} />
          </label> <br />
          <Submit small={true} type="submit" >set</Submit><br />
        </Form>
        {firstGuessError ? <label>Please enter a 5-letter word</label> : null}
      </>
        : null}
      {gameState === 'playing' ? <p>When Wordle responds, click the letters to update the current Knowledge and get your best next word.</p> : null}
      {
        guesses.map((word, idx) => (
          <AnswerSelector key={idx} currentGlobalKnowledge={currentGlobalKnowledge} setGuesses={setGuesses} word={word} setCurrentGlobalKnowledge={setCurrentGlobalKnowledge} latest={idx === guesses.length - 1} />

        )

        )
      }
    </Wrapper>
  )
}

export default Home



const AnswerSelector: React.FC<AnswerSelectorProps> = ({ setGuesses, word, currentGlobalKnowledge, setCurrentGlobalKnowledge, latest }) => {

  const [serverError, setServerError] = React.useState<string>()

  const [thisWordKnowledge, setThisWordKnowledge] = React.useState<{ [idx in LetterIndices]: LetterState }>({
    0: currentGlobalKnowledge.get(word[0])!.state,
    1: currentGlobalKnowledge.get(word[1])!.state,
    2: currentGlobalKnowledge.get(word[2])!.state,
    3: currentGlobalKnowledge.get(word[3])!.state,
    4: currentGlobalKnowledge.get(word[4])!.state,
  });

  const handleLetterClick: React.MouseEventHandler<HTMLButtonElement> = (event) => {
    if (!latest) return;
    const idx = event.currentTarget.dataset.idx;
    if (idx) {

      setThisWordKnowledge(prev => ({
        ...prev,
        [idx]: (prev[Number(idx) as LetterIndices] + 1) % 3
      }))
    }
  }

  const updateGlobalKnowledge = async () => {

    const updatedGlobalKnowledge = new Map(currentGlobalKnowledge);

    for (let idx of [0, 1, 2, 3, 4]) {
      if (thisWordKnowledge[idx as LetterIndices] === LetterState.CORRECT) {
        updatedGlobalKnowledge.set(word[idx as LetterIndices], { state: LetterState.CORRECT, idx: idx as LetterIndices, notAtIdx: [] });
        continue;
      }
      if (thisWordKnowledge[idx as LetterIndices] === LetterState.MISPLACED) {
        const thisLetterKnowledge = updatedGlobalKnowledge.get(word[idx as LetterIndices]);
        if (thisLetterKnowledge) {
          thisLetterKnowledge.state = LetterState.MISPLACED;
          thisLetterKnowledge.notAtIdx.push(idx as LetterIndices);
          continue;
        }
        updatedGlobalKnowledge.set(word[idx as LetterIndices], { state: LetterState.MISPLACED, idx: null, notAtIdx: [idx as LetterIndices] })
        continue;
      }
      if (thisWordKnowledge[idx as LetterIndices] === LetterState.WRONG) {
        updatedGlobalKnowledge.set(word[idx as LetterIndices], { state: LetterState.WRONG, idx: null, notAtIdx: [] })
        continue;
      }
    }

    setCurrentGlobalKnowledge(updatedGlobalKnowledge); updatedGlobalKnowledge

    await fetch('/api/generate-next-word', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(updatedGlobalKnowledge, replacer)
    }).then(res => res.json().then(res => setGuesses(prev => [...prev, res.word]))).catch(e => setServerError(e.message))
  }

  return (
    <LettersWrapper>
      <SLetter data-idx={0} onClick={handleLetterClick} letterState={thisWordKnowledge[0]}>{word[0]}</SLetter>
      <SLetter data-idx={1} onClick={handleLetterClick} letterState={thisWordKnowledge[1]}>{word[1]}</SLetter>
      <SLetter data-idx={2} onClick={handleLetterClick} letterState={thisWordKnowledge[2]}>{word[2]}</SLetter>
      <SLetter data-idx={3} onClick={handleLetterClick} letterState={thisWordKnowledge[3]}>{word[3]}</SLetter>
      <SLetter data-idx={4} onClick={handleLetterClick} letterState={thisWordKnowledge[4]}>{word[4]}</SLetter>
      {latest && <Submit small={false} onClick={updateGlobalKnowledge} >get my next word</Submit>}
    </LettersWrapper>
  )
}


/**
 * UTILS
 */

const generateInitialKnowledgeMap = (): Map<Letter, KnowledgeItem> => {
  const map = new Map<Letter, KnowledgeItem>();
  for (let letter of alphabet.split('')) {
    map.set(letter, { state: LetterState.UNKNOWN, idx: null, notAtIdx: [] });
  }
  return map;

}


